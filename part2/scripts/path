#!/usr/bin/env python

import math
import rospy
import tf2_ros
import tf2_geometry_msgs
from tf.transformations import euler_from_quaternion
from geometry_msgs.msg import PoseStamped
from crazyflie_driver.msg import Position
import numpy as np

idx = 0 #current pose index
STATE_MOVE = 0
STATE_WAIT = 1
STOP_THRESHOLD = 100
DIST_THRESHOLD = 0.1
NPOINTS = 6
[ 0.0, 3.0,  0.00]
poses = np.array([[6.0, 0.0, 0.4, 0.0 ],#gate0
         [0.0, 4.0, 0.4, 90.0], # before gate 1
         [0.0, 2.0, 0.4, 90.0 ], #after gate 1
         [-6.0, 2.0, 0.4, 0.0],
         [-6.0, 0.0, 0.4, 0.0], # before gate 2
         [0.0, 0.0, 0.4, 0.0], #home
         ])
def publish_cmd(idx):
    goal = PoseStamped()

    goal.header.stamp = rospy.Time.now()
    goal.header.frame_id = "map"

    goal.pose.position.x = poses[idx, 0]
    goal.pose.position.y = poses[idx, 1]
    goal.pose.position.z = poses[idx, 2]
    goal.pose.orientation.z = poses[idx, 3]
    #pub_cmd.publish(cmd)

    if not tf_buf.can_transform(goal.header.frame_id, 'cf1/odom', goal.header.stamp):
        #rospy.logwarn_throttle(5.0, 'No transform from %s to cf1/odom' % goal.header.frame_id)
        return

    goal_odom = tf_buf.transform(goal, 'cf1/odom')

    cmd = Position()

    cmd.header.stamp = rospy.Time.now()
    cmd.header.frame_id = goal_odom.header.frame_id

    cmd.x = goal.pose.position.x
    cmd.y = goal.pose.position.y
    cmd.z = goal.pose.position.z

    roll, pitch, yaw = euler_from_quaternion((goal_odom.pose.orientation.x,
                                              goal_odom.pose.orientation.y,
                                              goal_odom.pose.orientation.z,
                                              goal_odom.pose.orientation.w))

    cmd.yaw = math.degrees(yaw)

    pub_cmd.publish(cmd)


def pose_callback(msg):
    """
    Check if I am close enough to my goal, in that case stay there for a while and
    then start publishing the next pose.
    """
    global idx
    if pose_callback.state == STATE_MOVE:
        # Compute distance between current pose and goal
        pos = msg.pose.position
        orient = msg.pose.orientation
        d = np.array([poses[idx][0]-pos.x,
             poses[idx, 1]-pos.y,
             poses[idx, 2]-pos.z])
        distance = np.linalg.norm(d)
        publish_cmd(idx)
        
        if(distance < DIST_THRESHOLD):
            print("Arrived to the point, staying here a while")
            pose_callback.state = STATE_WAIT
        
    elif pose_callback.state == STATE_WAIT:
        # Wait here for some iterations
        pose_callback.count = pose_callback.count + 1
        publish_cmd(idx)
        
        if (pose_callback.count > STOP_THRESHOLD):
            #We've waited enough, start moving again to next point
            print("Moving to next point")
            pose_callback.count = 0
            pose_callback.state = STATE_MOVE
            idx = idx + 1
            idx = idx % NPOINTS
        
pose_callback.count = 0
pose_callback.state = STATE_MOVE

rospy.init_node('path')
tf_buf   = tf2_ros.Buffer()
tf_lstn  = tf2_ros.TransformListener(tf_buf)
pub_cmd  = rospy.Publisher('/cf1/cmd_position', Position, queue_size=2)
sub_pose = rospy.Subscriber('/cf1/pose', PoseStamped, pose_callback)

def main():
    rate = rospy.Rate(10)  # Hz
    rospy.sleep(10)
    rospy.spin()

if __name__ == '__main__':
    main()
